//
// Created by terae on 27/01/18.
//

#ifndef ROOT_ACTION_H
#define ROOT_ACTION_H

#include "../../librobot/libRobot.h"
#include "Element.hpp"

// TODO: include generated petri file (as "info/src/robot/Principal/petri/IA2017.h")
//#include <memory>
#include "Enum/Enum.h"
#include <petrilab/Cpp/MemberPetriDynamicLib.h>

namespace StrategyGenerator {
	class Element;

	ENUM_CLASS_NS(StrategyGenerator, ActionType, NOTHING, BEE, SWITCH, CUBE, SPHERE);

	/**
	* @brief Abstraction of an action in the Cup
	*/
	class Action {
	protected:
		// Execution time since the robot is at the good position & in the good angle (approximation)
		Duration _execution_time;
		// TODO: allow user to calculate the point while action is performing?
		int _nr_points;

		// in order to call AllerA() + TournerAbsolu() functions
		Vector2m _start_position;
		Angle _start_angle;

		// return a list of all new `Element`s generated by this action
		// return an empty list if the action is the last one
		std::vector<Element> _elements_created_after_call;

		ActionType _type;

		// Associated Petri network to launch
		// std::shared_ptr<Petri::PetriDynamicLib> _petri;

	public:
		Action() : Action(0_s, 0, {0_m, 0_m}, 0_deg, {}, ActionType::NOTHING) {}

		Action(Duration time, int points, Vector2m pos, Angle angle, std::vector<Element> elements_created_after_call, ActionType type /*, std::shared_ptr<Petri::PetriDynamicLib> petri*/)
		        : _execution_time(time)
		        , _nr_points(points)
		        , _start_position(pos)
		        , _start_angle(angle)
		        , _elements_created_after_call(std::move(elements_created_after_call))
		        , _type(type) /*, _petri(petri)*/ {}

		inline int get_nr_points() const {
			return _nr_points;
		}

		inline Vector2m get_start_position() const {
			return _start_position;
		}

		inline Angle get_start_angle() const {
			return _start_angle;
		}

		// TODO: add deplacement time
		inline Duration get_execution_time(Vector2m initial_pos) const {
			Distance dist{Distance::makeFromCm(std::sqrt(std::pow(initial_pos.x.toCm() - _start_position.x.toCm(), 2) +
			                                             std::pow(initial_pos.y.toCm() - _start_position.y.toCm(), 2)))};
			return _execution_time + dist / Constantes::LINEAR_SPEED_DEFAULT + 5_s;
		}

		inline std::vector<Element> get_next_elements() const {
			return _elements_created_after_call;
		}

		virtual void execute(Petri::PetriNet& petri, Duration remainingTime) {
			StopWatch start;
			petri.variables().pushVariables(static_cast<std::size_t>(_type));
			petri.run();

			while(petri.running() && start.getElapsedTime() < remainingTime) {
				sleep(50_ms);
			}

			petri.stop();
		}

		friend bool operator==(const Action& a1, const Action& a2) {
			return a1.get_start_position() == a2.get_start_position() && a1.get_start_angle() == a2.get_start_angle() &&
			       a1.get_nr_points() == a2.get_nr_points() && a1.get_next_elements() == a2.get_next_elements() &&
			       a1._execution_time == a2._execution_time;
		}

		friend bool operator!=(const Action& a1, const Action& a2) {
			return !(a1 == a2);
		}
	};

	class ActionWait : public Action {
	public:
		explicit ActionWait(Duration time) : Action(time, 0, {0_m, 0_m}, 0_deg, {}, ActionType::NOTHING) {}

		void execute(Petri::PetriNet&, Duration remainingTime) override {
			sleep(std::min(_execution_time, remainingTime));
		}
	};
}

#endif // ROOT_ACTION_H
