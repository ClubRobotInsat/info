//
// Created by terae on 27/01/18.
//

#ifndef ROOT_ACTION_H
#define ROOT_ACTION_H

#include "../../librobot/libRobot.h"
#include "Element.hpp"

// TODO: include generated petri file (as "info/src/robot/Principal/petri/IA2017.h")
//#include <memory>
#include "Enum/Enum.h"
#include <petrilab/Cpp/MemberPetriDynamicLib.h>
#include <petrilab/Cpp/PetriLab.h>

namespace StrategyGenerator {
	class Element;

	ENUM_CLASS_NS(StrategyGenerator, ActionType, NOTHING, BEE, SWITCH, CUBE, SPHERE);

	/**
	* @brief Abstraction of an action in the Cup
	*/
	class Action {
	protected:
		// Execution time since the robot is at the good position & in the good angle (approximation)
		Duration _execution_time;
		// TODO: allow user to calculate the point while action is performing?
		int _nr_points;

		// in order to call AllerA() + TournerAbsolu() functions
		repere::Coordonnees _start_coords;

		// return a list of all new `Element`s generated by this action
		// return an empty list if the action is the last one
		std::vector<Element> _elements_created_after_call;

		ActionType _type;

		std::string _name;
		// Associated Petri network to launch
		// std::unique_ptr<Petri::PetriDynamicLib> _petri;

	public:
		Action(Duration time, int points, repere::Coordonnees coords, std::vector<Element> elements_created_after_call, ActionType type, std::string name)
		        : _execution_time(time)
		        , _nr_points(points)
		        , _start_coords(coords)
		        , _elements_created_after_call(std::move(elements_created_after_call))
		        , _type(type)
		        , _name(name) {}

		inline int get_nr_points() const {
			return _nr_points;
		}

		inline repere::Coordonnees get_coordonnees() const {
			return _start_coords;
		}

		// TODO: add deplacement time
		inline Duration get_execution_time(const repere::Coordonnees& initial_coords) const {
			Distance dist{
			    Distance::makeFromCm(std::sqrt(std::pow(initial_coords.getX().toCm() - _start_coords.getX().toCm(), 2) +
			                                   std::pow(initial_coords.getY().toCm() - _start_coords.getY().toCm(), 2)))};
			return _execution_time + dist / Constantes::LINEAR_SPEED_DEFAULT + 5_s;
		}

		inline std::vector<Element> get_next_elements() const {
			return _elements_created_after_call;
		}

		virtual void execute_petri(Petri::PetriNet& petri, Duration remainingTime) const {
			StopWatch start;
			// petri.variables().pushVariables(static_cast<std::size_t>(_type));
			petri.run();

			while(/*petri.running() && */ start.getElapsedTime() < remainingTime) {
				sleep(50_ms);
			}

			petri.stop();
		}

		friend bool operator==(const Action& a1, const Action& a2) {
			return a1._start_coords == a2._start_coords && a1.get_nr_points() == a2.get_nr_points() &&
			       a1.get_next_elements() == a2.get_next_elements() && a1._execution_time == a2._execution_time;
		}

		friend bool operator!=(const Action& a1, const Action& a2) {
			return !(a1 == a2);
		}

		friend std::ostream& operator<<(std::ostream& os, const Action& action) {
			return os << action._name;
		}
	};

	class ActionWait : public Action {
	public:
		explicit ActionWait(Duration time)
		        : Action(time, 0, repere::Coordonnees(), {}, ActionType::NOTHING, "wait " + std::to_string(time.toMs()) + "ms") {}

		void execute_petri(Petri::PetriNet&, Duration remainingTime) const override {
			sleep(std::min(_execution_time, remainingTime));
		}
	};
}

#endif // ROOT_ACTION_H
