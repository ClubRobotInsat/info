/*
 * Generated by the petri net editor - https://github.com/rems4e/petri
 * Version 2.1.8
 */

#include <cstdint>
#include "Runtime/Cpp/Action.h"
#include "Runtime/Cpp/Atomic.h"
#include "Runtime/Cpp/MemberPetriDynamicLib.h"
#include "Runtime/Cpp/PetriDebug.h"
#include "Runtime/Cpp/PetriUtils.h"
#include "../Deplacement.h"
#include "../Servo.h"
#include "../Utils.h"

#define EXPORT extern "C"
#define PETRI_PREFIX "IA"

using namespace Petri;

struct FillResult {
	void *start;
	void *end;
};


static Petri_actionResult_t state_0_invocation(Entity &_PETRI_PRIVATE_GET_ENTITY_) {
	return static_cast<actionResult_t>(Petri::Utility::doNothing());
}

static Petri_actionResult_t state_1_invocation(Entity &_PETRI_PRIVATE_GET_ENTITY_) {
	return static_cast<actionResult_t>(Petri::Utility::doNothing());
}

static Petri_actionResult_t state_2_invocation(Entity &_PETRI_PRIVATE_GET_ENTITY_) {
	return static_cast<actionResult_t>(allerA(static_cast<Distance>(1_m), static_cast<Distance>(0.5_m)));
}

static Petri_actionResult_t state_3_invocation(Entity &_PETRI_PRIVATE_GET_ENTITY_) {
	return static_cast<actionResult_t>(Petri::Utility::doNothing());
}

static bool transition_5_invocation(Entity &_PETRI_PRIVATE_GET_ENTITY_, Petri_actionResult_t _PETRI_PRIVATE_GET_ACTION_RESULT_) {
	return true;
}

static bool transition_4_invocation(Entity &_PETRI_PRIVATE_GET_ENTITY_, Petri_actionResult_t _PETRI_PRIVATE_GET_ACTION_RESULT_) {
	return true;
}


EXPORT FillResult IA_fill(PetriNet &petriNet, std::uint64_t entitiesOffset, std::uint_fast32_t variablesOffset, bool firstLevel) {
	auto &state_0 = petriNet.addAction(Action(petriNet, 0 + entitiesOffset, "Root_Entry", &state_0_invocation, 0), firstLevel, variablesOffset);
	auto &state_1 = petriNet.addAction(Action(petriNet, 1 + entitiesOffset, "Root_3", &state_1_invocation, 0), false, variablesOffset);
	auto &state_2 = petriNet.addAction(Action(petriNet, 2 + entitiesOffset, "Root_4", &state_2_invocation, 1), false, variablesOffset);
	auto &state_3 = petriNet.addAction(Action(petriNet, 3 + entitiesOffset, "Root_End", &state_3_invocation, 0), false, variablesOffset);


	auto &transition_5 = state_0.addTransition(5 + entitiesOffset, "Root_Entry_to_3", state_1, &transition_5_invocation);
	auto &transition_4 = state_1.addTransition(4 + entitiesOffset, "Root_3", state_2, &transition_4_invocation);

	return (FillResult){&state_0, &state_3};
}

EXPORT void *IA_create() {
	auto petriNet = std::make_unique<PetriNet>(PETRI_PREFIX);
	IA_fill(*petriNet, 0, 0, true);
	return petriNet.release();
}

EXPORT void *IA_createDebug() {
	auto petriNet = std::make_unique<PetriDebug>(PETRI_PREFIX);
	IA_fill(*petriNet, 0, 0, true);
	return petriNet.release();
}

EXPORT char const *IA_getHash() {
	return "C3B758DB83DA93708125890A2B730604EE20239A";
}

#define NO_C_PETRI_NET
#include "Runtime/C/detail/Types.hpp"

EXPORT void *IA_createLibForEditor() {
	return new ::PetriDynamicLib{std::make_unique<::Petri::MemberPetriDynamicLib>(false, "IA", 12346)};
}


